import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
async function queryKnowledge(q){ const base = process.env.NEXT_PUBLIC_BASE_URL || ''; const res = await fetch(`${base}/api/knowledge?q=${encodeURIComponent(q)}`); if(!res.ok) return []; const body = await res.json(); return body.items || []; }
export async function POST(req){ try{ if(!OPENAI_API_KEY) return NextResponse.json({ ok:false, error:'OPENAI_API_KEY not set' }, { status:500 }); const { question, userId } = await req.json(); const matches = await queryKnowledge(question); const contextItems = matches.slice(0,3).map(m=>`Source: ${m.source||m.file||m.title}\nTitle: ${m.title}\n\n${(m.text||'').slice(0,12000)}\n`).join('\n---\n'); const systemPrompt = `You are Ztake AI Assistant. Use ONLY the provided context to answer. Context:\n\n${contextItems}`; const openaiRes = await fetch('https://api.openai.com/v1/chat/completions', { method:'POST', headers:{ 'Authorization': `Bearer ${OPENAI_API_KEY}`, 'Content-Type':'application/json' }, body: JSON.stringify({ model:'gpt-4o-mini', messages:[{ role:'system', content: systemPrompt }, { role:'user', content: question }], temperature:0.0, stream:true, max_tokens:1500 }) }); if(!openaiRes.ok){ const txt = await openaiRes.text(); return NextResponse.json({ ok:false, error: txt }, { status:500 }); } const stream = new ReadableStream({ async start(controller){ const reader = openaiRes.body.getReader(); const decoder = new TextDecoder(); while(true){ const { done, value } = await reader.read(); if(done) break; const chunk = decoder.decode(value); controller.enqueue(new TextEncoder().encode(chunk)); } controller.close(); } }); try{ const LOG_PATH = path.join(process.cwd(),'data','logs.json'); fs.mkdirSync(path.dirname(LOG_PATH), { recursive: true }); const logs = fs.existsSync(LOG_PATH)? JSON.parse(fs.readFileSync(LOG_PATH,'utf-8')):[]; logs.push({ userId: userId||null, question, answer: null, sources: matches.slice(0,3).map(m=>m.title||m.source), ts: new Date().toISOString() }); fs.writeFileSync(LOG_PATH, JSON.stringify(logs,null,2),'utf-8'); }catch(e){ console.error('log error', e) } return new Response(stream, { headers: { 'Content-Type': 'text/event-stream' } }); }catch(e){ console.error(e); return NextResponse.json({ ok:false, error: e.message }, { status:500 }); } }
